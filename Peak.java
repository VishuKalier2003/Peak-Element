/* A peak element is an element that is strictly greater than its neighbors...
Given a 0-indexed integer array nums, find a peak element, and return its index... If the array contains multiple peaks, return the index to any of the peaks...
You may imagine that nums[-1] = nums[n] = -∞... In other words, an element is always considered to be strictly greater than a neighbor that is outside the array...
You must write an algorithm that runs in O(log n) time...
* Eg 1:  nums = [1,2,3,1]                             Peak = 2 
* Eg 2:  nums = [1,2,1,3,5,6,4]                       Peak = 1 
* Eg 3:  nums = [0]                                   Peak = 0
*/
import java.util.*;
public class Peak
{
    public int FindPeakElement(int nums[])
    {
        if(nums.length == 1)     // Base condition...
            return 0;
        if(nums[0] >= nums[1])    // If left most element is the peak...
            return 0;
        if(nums[nums.length - 1] >= nums[nums.length - 2])   // If right most element is the peak...
            return nums.length - 1;
        int start = 0, end = nums.length - 1;   // Creating start and end indices...
        while(start <= end)      // Search until the two indices meet...
        {
            int mid = start + (end - start)/2;   // Finding mid index...
            if((nums[mid] >= nums[mid - 1]) && (nums[mid] >= nums[mid + 1]))
                return mid;    // If th peak is found return mid index...
            else if(nums[mid] < nums[mid - 1])
                end = mid - 1;    // Shifting towards left...
            else if(nums[mid] < nums[mid + 1])
                end = mid + 1;    // Shifting towards right...
        }
        return -1;   // dummy return statement...
    }
    public static void main(String args[])
    {
        Scanner sc = new Scanner(System.in);
        int n;
        System.out.print("Enter the number of elements : ");
        n = sc.nextInt();
        int nums[] = new int[n];
        for(int i = 0; i < nums.length; i++)
        {
            System.out.print("Enter data : ");
            nums[i] = sc.nextInt();
        }
        Peak peak = new Peak();     // Object creation...
        System.out.print("The Index of Peak is : "+peak.FindPeakElement(nums));
        sc.close();
    }
}


// Time Complexity  - O(log n) time...
// Space Complexity - O(1) space...

/* DEDUCTIONS :
 * 1. We first apply binary search to check if the current index is peak or not...
 * 2. We check the left and right cases for the peak as well...
 */